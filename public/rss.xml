<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/">
    <channel>
        <title>Steve Kibuika || Javascript Blog</title>
        <link>https://kibuika.com</link>
        <description>undefined</description>
        <lastBuildDate>Tue, 28 Jun 2022 14:52:37 GMT</lastBuildDate>
        <docs>https://validator.w3.org/feed/docs/rss2.html</docs>
        <generator>https://github.com/jpmonette/feed</generator>
        <language>en-US</language>
        <copyright>Copyright Â© 2022 Steve Kibuika</copyright>
        <item>
            <title><![CDATA[Where are my Arrays and Strings ".at"?]]></title>
            <link>https://kibuika.composts/At-Prototype</link>
            <guid>At-Prototype</guid>
            <pubDate>Mon, 27 Jun 2022 21:00:00 GMT</pubDate>
            <description><![CDATA[The EcmaScript release on June 2022 (ES2022) introduced a new method (.at), it is okay-ish.]]></description>
            <content:encoded><![CDATA[
The new method ```.at()``` of indexable values allows us to read an element at a given index. Basically like the bracket ```[]``` operator. The pro is that it supports negative indices, which the bracket operator does not.

### Let's see

```js
// array of names
let names = ["John", "Jacob", "Jingleheimer", "Schmidt"];
console.log(names[0]) // "John"   ====>>> using the bracket operator
console.log(names.at(0)); // "John"  ====>> using the new .at() method
```

This is also the case with Strings  

```js
let person = "Steve";
console.log(person[0]) // 'S'
console.log(person.at(0)) // 'S'
```

But when it comes to using negative values, this is where ```.at()``` gets the bracket ```[]``` operator at.

```js
let person = "Steve";
console.log(person[-1]); // undefined
console.log(person.at(-1)); // 'e'
```

This is a useful feature though I have not gotten a proper use-case for it, but I am sure I will use it in the future. But besides ```.at()``` There are alot of cool features that were released with ES2022, including ```error.cause```, ```Top-level await in modules```, ```Object.hasOwn(obj, propKey)``` and others. Have a look at everything [ES2022](https://262.ecma-international.org/)

Cheers :)]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[How MutationObserver saved my weekend build]]></title>
            <link>https://kibuika.composts/MutationObserver</link>
            <guid>MutationObserver</guid>
            <pubDate>Mon, 27 Jun 2022 21:00:00 GMT</pubDate>
            <description><![CDATA[What it is, how it saved me from losing my mind, why you should care.]]></description>
            <content:encoded><![CDATA[
Over the weekend, I was working on some "fun" build. One of my favourite youtube channels `The Good Company KE` where I get my music mixes, does not name their videos properly. So if I am in the mood for some good pop-mix, I have to click around and fast-forward till I get the right video. Very exhausting. So I thought I could fix this using a chrome extension.

The extension's logic (simple version)  
```open youtube``` ===> ```check if it is a Grauchi Mix``` ===> ```get my comment from the video comments``` ===> ```replace this comment with the title```

This seems pretty straight forward, right?  
So let's write some code
```js
// get the video title
let videoTitle = document.querySelector("h1.title.style-scope.ytd-video-primary-info-renderer");
// lets see the value
console.log(videoTitle);
```
Ideally, if we have the right the reference to the title element, we should get the video title, so obvious.
But then I got a ```null``` when I logged to the console.  
Lets test in the console  

<img src="https://github.com/kibuikaCodes/kibuika.com/blob/main/content/assets/qs.png?raw=true" alt="title text">

It works!!!  

So it hit me that probably my code is running too early yet the title element has not been passed to the DOM tree.  

And that is where ```MutationObserver``` came in.

A ```MutationObserver``` is an interface that enables us to watch for changes being made to the DOM tree. This means, we can listen to some mutations and then perform an action that reacts according to that mutation.

The ```MutationObserver()``` constructor creates and returns a new MutationObserver which invokes the callback function you provide when changes occur in the DOM.
```js
const observer = new MutationObserver((mutations) => {}) 
// the callback can be different depending on your requirements
```

There are 3 methods we can invoke withing the MutationObserver.

 - ```observe()```. As the name suggests, this is what we invoke in order to configure the ```MutationObserver``` to begin receiving notifications. It can watch a single node or a node and its descendants.
    ```js
    observer.observe(target, config);
    // target is the node you want to listen to
    // config are options for the obsercer, could be the attributes you want to listen to, childList or subtree
    ```

 - ```disconnect()``` This stops an instance of the ```MutationObserver``` from receiving further notifications, until ```observe()``` is called again.
    ```js
    observer.disconnect();
    ```

 - ```takeRecords()``` Removes all pending notifications from the ```MutationObserver```'s notification queue and return them in a new array.


From this, I redesigned how my extension works. So not it listens for changes to the node with the video title and then executes my script. Simply:

```js
const observer = new MutationObserver(mutations => {
    mutations.forEach(mutation => {
        if(mutation.addedNodes.length){
            if(mutation.type == "childList"){
                console.log(mutation.target.innerText)
            }
        }
    })
})

const checkTitle = () => {
    let targetNode = document.querySelector("h1.title.style-scope.ytd-video-primary-info-renderer");
    if (!targetNode) {
        window.setTimeout(checkTitle, 500); // delay the execution so all content loads.
        return;
    }
    // any other logic here
    //
    //
    console.log(targetNode.innerText); // now we get our title

    observer.observe(targetNode, {childList: true, subtree: true}); // listens to DOM changes
}

checkTitle();
```

And viola!!! Now we can get our title.

I probably haven't explained enough of ```MutationObserver```, it is definitely a topic that deserves its own article. But MDN, like with everything else, has explained it and its methods very well. Here is the article [MDN MutationObserver](https://developer.mozilla.org/en-US/docs/Web/API/MutationObserver)

Cheers :)








]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[Primitives vs Objects (Value vs Reference)]]></title>
            <link>https://kibuika.composts/value-vs-reference</link>
            <guid>value-vs-reference</guid>
            <pubDate>Sat, 25 Jun 2022 21:00:00 GMT</pubDate>
            <description><![CDATA[A light look into values and references.]]></description>
            <content:encoded><![CDATA[
I'll kick this off with some examples that will act as the base of this article.

```js
const a = 1
const b = 2

a === b // false

const c = 1
const d = 1

c === d // true

const e = [1]
const f = [1]
const g = f

e === f // false
e === [1] // false
g === f // true
```

The comparison of a and b makes sense, right? But for the comparison of e and f, e and [1], g and f, that is where things get interesting. Someone who doesn't know what is actually happening will just say Javascript is weird, but it really isn't.

Javascript provides us with two types of datatypes: Primitives and Objects. Each of this datatype is passed differently to a variable. Primitives are passed by value while Objects are passed by reference.

## Primitives
Primitives are numbers, booleans, strings, symbols and special values like undefined and null

```js
const number = 2;
const boolean = true;
const string = 'Hello World!';
const missingItem = null;
const nothing = undefined;
```

Like I said, primitive values are passed by value. This means that every time you assign a primitive value to a variable, a copy of that value is created. 

```js
let a = 10; 
let b = a;

// mutate b
b = b + 10;

console.log(b) // 20
console.log(a) // 10
```

The very first statement declares a variable ```a``` and initializes it with the number ```1```. The second statement ```let b = a```, declares another variable ```b``` and initializes it with the value of the variable ```a```. Since we are dealing with primitives here, a copy of the number ```1``` is assigned to ```b```.

When we change the the value of ```b```, ```b = b + 10```, we are basically increasing the value of ```b``` by ```10```. Notice the value of ```b``` increases to ```20``` while the value of ```a``` remains the same.

## Objects
Objects are the other category od fata types that Javascript provides us. Objects include: the plain object, arrays, functions, dates, regex, etc. Anything that is not a primitive is an object in js.

```js
const person = {
    name: "Steve"
}

const array = [2, 3, 4, 5]

const functionObj = (a1, a2) => {
    return a1 + a2;
}
```

Unlike primitive values where the value assigned to a variable is the actual copy of that value, objects are assigned by reference. This means that when you declare a variable ```person``` and assign it an object, that object is created in memory and the address of that memory location is assigned to the variable ```person```.

Let's break this down.
```js 
const person = {
    name: "Steve"
}
```
The object ```{name: "Steve"}``` is created in memory and the location of that memory is, let's say ```1234567```, this is the address that points to that location in memory. Ideally this ```address``` is what is "assigned" to the variable ```person```.
So instead of ```person``` holding an actual copy of the onject, it just points to a location in memory where the object has been created.

```person =============> 1234567```
```js
 // address 1234567
 {
    name: "Steve"
 }
 ```

 What happens when we assign a new variable the value of an existing object?

 ```js
 let person = {
    name: "Steve"
 }

 let newPerson = person;

 newPerson.age = 24;

 console.log(person) // {name: "Steve", age: 24}
 console.log(newPerson) // {name: "Steve", age: 24}

 ```

 What tha heck!!. Yes. Remember when we said that ```Objects```(the data type) points to memory locations? This is what is happening. Our object ```{name: "Steve"}``` is created in memory and its address is "assigned" to the variable person. When we declare a new variable ```newPerson``` and assign it the value of ```person```, what we are doing is assigning a reference to the memory location. Basically, both ```person``` and ```newPerson``` are pointing to the same memory location.

 ```person ============> 1234567```
 ```newPerson ===========> 1234567```

 That is why when we add a new property ```age``` with a value of ```24``` to ```newPerson```, this also applies to ```person``` because it is pointing to the same memory location.

 And this is what ```pass by reference``` is all about. We are passing references and not actual values.


 ### Highlights
 - Javascript is not weird
 - Pass by value means an actual copy of that value is assigned to the variable. This happens with ```Primitives``` data types (numbers, strings, boolean, null, undefined)
 - Pass by reference means that the value is created in memory and an address to that memory location is what the variable will "hold". This happens with ```Objects``` data types (object, array, function, date, regex)
]]></content:encoded>
        </item>
    </channel>
</rss>