<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/">
    <channel>
        <title>My space on the internet</title>
        <link>https://kibuika.com</link>
        <description>undefined</description>
        <lastBuildDate>Mon, 13 Mar 2023 12:55:43 GMT</lastBuildDate>
        <docs>https://validator.w3.org/feed/docs/rss2.html</docs>
        <generator>https://github.com/jpmonette/feed</generator>
        <language>en-US</language>
        <copyright>Copyright Â© 2023 Steve Kibuika</copyright>
        <item>
            <title><![CDATA[Ruby; If love was a programming language]]></title>
            <link>https://kibuika.composts/Ruby-Is-Cute</link>
            <guid>Ruby-Is-Cute</guid>
            <pubDate>Thu, 26 Jan 2023 21:00:00 GMT</pubDate>
            <description><![CDATA[Ruby is just one of those languages that is just so easy to love.]]></description>
            <content:encoded><![CDATA[
A while ago, I decided to check out Ruby - the language. It was a slow Sunday and I had just started this routine where I set Sundays as the days when I tinker with new things. To be honest, going in, I just wanted to evaluate if Ruby is a language I can pick up and maybe do a side project with. Nothing prepared me for what I found.


### How I'd learn a new language

Typically, when you already know something and you are learning something else that is almost similar, it is common to try and compare and contast. It's like learning to fly a plane when you already can drive a vehicle. There are definitely terminologies and techniques that will be similar across. So that is how I was learning Ruby, learning from a point of "Ohh this is how we do it in Javascript, what is it's equivalent in Ruby?". Interestingly, there are things I learnt that they exist in Javascript after I saw them in Ruby, for example, Class Extensions, I had used them before, and React also uses them ``` Class App extends React.Component ``` but I had never though of them deeply.


### The joy of Ruby

While in Javascript I would write `` console.log("something") `` in order to write something out, in Ruby, I just `` puts "something" ``, while in JS we'd `` let name = "Steve" ``, in Ruby, we `` name = "Steve" `` and while in JS we'd `` console.log(parseInt("12")) `` to convert a string to an integer and print it out, in Ruby we `` puts "12".to_i ``. It is either that my standards are too low or I have no standards at all, but this makes me feel so special. It is as if the language itself cares about me, that it doesn't want me to struggle, like it wants to pick me up, take me out for drinks and drop me back home, and text me in the morning ... okay, I am drifting ... anyway, you get it.


### Nuances (or whatever this word means)

 - Puts
    As demonstrated above, `` puts `` is used to write onto the screen. But see this
    ``` ruby
    puts 20 # --> 20
    puts 20.to_s # --> 20
    puts '20' # --> 20

    ```

    All these will output the same value, you'd think that the first one would output the number `` 20 `` but it doesn't, instead, it outputs the string `` 20 ``. Here is the thing - `` puts ``, before it outputs an object, it uses `` to_s `` to get the string version of that object, apparently, the `` s `` in `` puts `` stands for `` string ``. `` puts `` really means `` put string ``.


- Constant Variables
    Constants are declared with a capital letter. * insert mind-blown meme * . Yes!, while in JS we'd `` const name = "Steve" ``, in Ruby, we `` NAME = "Steve" ``. Crap! I love this language.


 - Just like my relationships, most things `` end ``
     Yes, `` end `` is a keyword here. It is used to indicate the end of loops, methods and blocks. 

     ``` ruby
     # typical if statement
     if 1 > 2
        puts "Yes, it is!"
    else
        puts "No, it's not!"
    end

    # custom method
    def sayMoo 
    puts 'mooooooo...'
    end

    sayMoo # calling a method


    # method to get the double of a number
    def doubleThis num
    numTimes2 = num * 2
        return 'return value is '+ numTimes2.to_s # the "return" keyword is optional
    end
    returnValue = doubleThis 44
    puts returnValue

    ```

    Curly braces are technically non-existent, I am yet to use them. Surely, if this ain't beauty, what is !!


I plan to use Ruby much more, my intention is to pick up Ruby on Rails, but of course I had to skim through Ruby, didn't think I'd like it but now I think whoever said *"We find love in the most uncommon of places"* should be given a microphone more often.

I may start streaming my programming tinkering on Twitch and/or Youtube but I guess they'll be private streams for a while, anyway, I'll try document my journey with Ruby as much as I can.


See you in the next one :)
]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[Sharp breaking prod]]></title>
            <link>https://kibuika.composts/sharp-breaking-prod</link>
            <guid>sharp-breaking-prod</guid>
            <pubDate>Mon, 03 Oct 2022 21:00:00 GMT</pubDate>
            <description><![CDATA[Packaging lambda function failed with the error Command failed with exit code 1: npm install --no-bin-links --production.]]></description>
            <content:encoded><![CDATA[
I work a lot with AWS, I am not a pro but I can find my way around most things.

Recently, we introduced a requirement to compress images that are being stored on S3. For a "not-yet-launched" project, I was a bit against the idea but then I thought it would be a great challenge.

You see there are two ways to approach this problem.

1. Compress the images client-side and upload an already compressed image.
2. Compress the images server-side.

As a "cool" Web dev, I know how option 1 is wrong. When building for great experiences, the main idea is to do only the necessary thing on the client-side and most of the heavy lifting on the server-side. The user doesn't care whether you are compressing images or not, so you really don't have to do this client-side.

So server-side was the best bet, or rather "best practice". I am hacky, like my mind thinks in bits, not computer bits but "small things" bits. If you showed me a forest, I will think about the trees. In this case, that I what I did, I started thinking about the trees, the granular things that make together the solution.

Remember when I said I am not an AWS pro, yea, I am really not. For this, I though I should create an endpoint that would take an uncompressed image, compress it and return the result, which would ideally work. But AWS is too smart for this.

### Here comes S3 Triggers.

S3 triggers allows you to fire a lambda function when an action is performed on S3. In this case, the action would be "an image has been inserted", my lambda function would be triggered and then this lambda function would compress the image and save it again.

I know you are smart enough to notice an infinite loop here. If a lambda is triggered when an image is saved and this lambda saves an image, won't that trigger the lambda again? Yes it will. 

I will talk about S3 triggers in depth as it's own post.

Anyway, moving along.

### Sharp - the compresser of my images, the breaker of my prod

Sharp is a high performance Node.js image processing library. Of course I needed it to compress my images.

The main caveat it that Sharp is sort of platform agnostic yet it requires a specific binary installation for the platform it runs on. On my machine, Sharp will run on the Windows x86 platform, but on prod (AWS servers) it will be running on the Linux x64 platform.

Without putting this into consideration, the build step for the lambdas will throw an error:

```bash
[0mError: Packaging lambda function failed with the error [0m
                                 [0mCommand failed with exit code 1: npm install --no-bin-links --production[0m
                                 [0msh: prebuild-install: command not found[0m
                                 [0m../src/common.cc:24:10: fatal error: vips/vips8:  [0m
                                 [0m #include <vips/vips8>[0m
                                 [0m          ^~~~~~~~~~~~[0m
                                 [0mcompilation terminated.[0m
                                 [0mmake: *** [Release/obj.target/sharp-linux-x64/src/common.o] Error 1[0m
                                 [0mgyp ERR! build error [0m
```


Notice there is a line that has ``prebuild-install: command not found``. Yea, apparently, we need a prebuild-install to include binaries for the Linux x64 platform to the ``node_modules`` directory of the deployment package.

##### The solution
In the ``package.json`` of your lambda function, make sure you add a prebuild-install like so:

```json
{
  "name": "s3imagecompression",
  "version": "2.0.0",
  "description": "Lambda function generated by Amplify",
  "main": "index.js",
  "license": "Apache-2.0",
  "scripts": {
    "preinstall": "SHARP_IGNORE_GLOBAL_LIBVIPS=1 npm install --arch=x64 --platform=linux --libc=glibc sharp"
  },
  "dependencies": {
    "@types/aws-lambda": "^8.10.92",
    "aws-sdk": "^2.778.0",
    "sharp": "^0.31.0"
  }
}
```


And that's it. 

Push your code and watch Amplify go green


Cheers :)
]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[Wtf, Javascript!!]]></title>
            <link>https://kibuika.composts/wtf-javascript</link>
            <guid>wtf-javascript</guid>
            <pubDate>Mon, 25 Jul 2022 21:00:00 GMT</pubDate>
            <description><![CDATA[Weird Javascript.]]></description>
            <content:encoded><![CDATA[
Last week, I tweeted this
<img src="https://github.com/kibuikaCodes/kibuika.com/blob/main/content/assets/wtf.png?raw=true" alt="title text">

When you run this on the console, it logs ``Friday!!!``. Yes it does. It blew my mind and so did everyone's in the comments.

why, how, WTF!!

### JS f***
It all started when I was listening to one of my favourite Javascript podcasts [JS Party](https://open.spotify.com/episode/2mGghkKlz708lortv74m7T?si=1642e8869df84c56) and on this episode, they were talking about weird Javascript syntax. One of the things they mentioned was this way of writing JS, it fascinated me and so I went on a deep dive into it.

That's how I found [JSFuck](http://www.jsfuck.com/), an esoteric and educational programming style besed on the atomic parts of Javascript.

```js
console.log([]) // []

console.log(+[]) // 0

console.log(![]) // false

console.log(![]+[]) // 'false'
```

The main idea is that there exists a very specific set of symbols and characters that can be used to write the code. In the example above, we see how we can use the ``[]`` character to get a number and a string by using the ``+``(plus sign) to cast the array literal to a string. 
The plus sign can also be used to:
    - Add two values (of course)
    - Create numbers (``!![]+!![]`` will give us 2)
    - Create strings
    - Concatenate strings

The other main character in the JSFuck set is the ``!`` (Logical NOT operator). This one is mainly used to cast to boolean and from there, we can convert the booleans to strings and further access the individual string characters.

```js
console.log(!![])  // true

console.log(!![]+[]) // 'true'
```

The double NOT operators cast the empty array to a boolean value, adding an empty array to the boolean value gives us a string character. So if we wanted the letter ``t``, we'd get it by ``(!![]+[])[![]+![]]``.

```js
console.log((!![]+[])[![]+![]])   // 't'
```

Breaking this down, there are 2 parts to this:
    - Generating the string
    - Accessing the single element

``(!![]+[])`` gives us ``'true'``, next, we just need to access the string character, normally, we'd do this by using ``[0]``, but this is JSFuck, we have to abstract the ``0``, so it becomes ``[![]+![]]``, which is essentially ``false+false``.

Anyway, this is not something you'd write maybe never, but it is cool to know it exists. It has been fun watching my friends loose their minds when I show them this.

Other languge esometrics are being built from the motivation of JSFuck, there's PyFuck btw. If I can learn Go fast enough, I can build GoFuck, which is a really good name btw. 

That's all...

```js
console.log(
    [][(![]+[])[+[]]+(![]+[])[!+[]+!+[]]+(![]+[])[+!+[]]+(!![]+[])[+[]]][([][(![]+[])[+[]]+(![]+[])[!+[]+!+[]]+(![]+[])[+!+[]]+(!![]+[])[+[]]]+[])[!+[]+!+[]+!+[]]+(!![]+[][(![]+[])[+[]]+(![]+[])[!+[]+!+[]]+(![]+[])[+!+[]]+(!![]+[])[+[]]])[+!+[]+[+[]]]+([][[]]+[])[+!+[]]+(![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[+!+[]]+([][[]]+[])[+[]]+([][(![]+[])[+[]]+(![]+[])[!+[]+!+[]]+(![]+[])[+!+[]]+(!![]+[])[+[]]]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[][(![]+[])[+[]]+(![]+[])[!+[]+!+[]]+(![]+[])[+!+[]]+(!![]+[])[+[]]])[+!+[]+[+[]]]+(!![]+[])[+!+[]]]((!![]+[])[+!+[]]+(!![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+([][[]]+[])[+[]]+(!![]+[])[+!+[]]+([][[]]+[])[+!+[]]+(+[![]]+[][(![]+[])[+[]]+(![]+[])[!+[]+!+[]]+(![]+[])[+!+[]]+(!![]+[])[+[]]])[+!+[]+[+!+[]]]+(!![]+[])[!+[]+!+[]+!+[]]+(+(!+[]+!+[]+!+[]+[+!+[]]))[(!![]+[])[+[]]+(!![]+[][(![]+[])[+[]]+(![]+[])[!+[]+!+[]]+(![]+[])[+!+[]]+(!![]+[])[+[]]])[+!+[]+[+[]]]+([]+[])[([][(![]+[])[+[]]+(![]+[])[!+[]+!+[]]+(![]+[])[+!+[]]+(!![]+[])[+[]]]+[])[!+[]+!+[]+!+[]]+(!![]+[][(![]+[])[+[]]+(![]+[])[!+[]+!+[]]+(![]+[])[+!+[]]+(!![]+[])[+[]]])[+!+[]+[+[]]]+([][[]]+[])[+!+[]]+(![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[+!+[]]+([][[]]+[])[+[]]+([][(![]+[])[+[]]+(![]+[])[!+[]+!+[]]+(![]+[])[+!+[]]+(!![]+[])[+[]]]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[][(![]+[])[+[]]+(![]+[])[!+[]+!+[]]+(![]+[])[+!+[]]+(!![]+[])[+[]]])[+!+[]+[+[]]]+(!![]+[])[+!+[]]][([][[]]+[])[+!+[]]+(![]+[])[+!+[]]+((+[])[([][(![]+[])[+[]]+(![]+[])[!+[]+!+[]]+(![]+[])[+!+[]]+(!![]+[])[+[]]]+[])[!+[]+!+[]+!+[]]+(!![]+[][(![]+[])[+[]]+(![]+[])[!+[]+!+[]]+(![]+[])[+!+[]]+(!![]+[])[+[]]])[+!+[]+[+[]]]+([][[]]+[])[+!+[]]+(![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[+!+[]]+([][[]]+[])[+[]]+([][(![]+[])[+[]]+(![]+[])[!+[]+!+[]]+(![]+[])[+!+[]]+(!![]+[])[+[]]]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[][(![]+[])[+[]]+(![]+[])[!+[]+!+[]]+(![]+[])[+!+[]]+(!![]+[])[+[]]])[+!+[]+[+[]]]+(!![]+[])[+!+[]]]+[])[+!+[]+[+!+[]]]+(!![]+[])[!+[]+!+[]+!+[]]]](!+[]+!+[]+!+[]+[!+[]+!+[]])+(![]+[])[+!+[]]+(![]+[])[!+[]+!+[]])()([][(![]+[])[+[]]+(![]+[])[!+[]+!+[]]+(![]+[])[+!+[]]+(!![]+[])[+[]]][([][(![]+[])[+[]]+(![]+[])[!+[]+!+[]]+(![]+[])[+!+[]]+(!![]+[])[+[]]]+[])[!+[]+!+[]+!+[]]+(!![]+[][(![]+[])[+[]]+(![]+[])[!+[]+!+[]]+(![]+[])[+!+[]]+(!![]+[])[+[]]])[+!+[]+[+[]]]+([][[]]+[])[+!+[]]+(![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[+!+[]]+([][[]]+[])[+[]]+([][(![]+[])[+[]]+(![]+[])[!+[]+!+[]]+(![]+[])[+!+[]]+(!![]+[])[+[]]]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[][(![]+[])[+[]]+(![]+[])[!+[]+!+[]]+(![]+[])[+!+[]]+(!![]+[])[+[]]])[+!+[]+[+[]]]+(!![]+[])[+!+[]]]((!![]+[])[+!+[]]+(!![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+([][[]]+[])[+[]]+(!![]+[])[+!+[]]+([][[]]+[])[+!+[]]+(+[![]]+[][(![]+[])[+[]]+(![]+[])[!+[]+!+[]]+(![]+[])[+!+[]]+(!![]+[])[+[]]])[+!+[]+[+!+[]]]+(!![]+[])[!+[]+!+[]+!+[]]+(![]+[])[!+[]+!+[]+!+[]]+([][(![]+[])[+[]]+(![]+[])[!+[]+!+[]]+(![]+[])[+!+[]]+(!![]+[])[+[]]]+[])[!+[]+!+[]+!+[]]+(![]+[])[+!+[]]+(+(!+[]+!+[]+[+!+[]]+[+!+[]]))[(!![]+[])[+[]]+(!![]+[][(![]+[])[+[]]+(![]+[])[!+[]+!+[]]+(![]+[])[+!+[]]+(!![]+[])[+[]]])[+!+[]+[+[]]]+([]+[])[([][(![]+[])[+[]]+(![]+[])[!+[]+!+[]]+(![]+[])[+!+[]]+(!![]+[])[+[]]]+[])[!+[]+!+[]+!+[]]+(!![]+[][(![]+[])[+[]]+(![]+[])[!+[]+!+[]]+(![]+[])[+!+[]]+(!![]+[])[+[]]])[+!+[]+[+[]]]+([][[]]+[])[+!+[]]+(![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[+!+[]]+([][[]]+[])[+[]]+([][(![]+[])[+[]]+(![]+[])[!+[]+!+[]]+(![]+[])[+!+[]]+(!![]+[])[+[]]]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[][(![]+[])[+[]]+(![]+[])[!+[]+!+[]]+(![]+[])[+!+[]]+(!![]+[])[+[]]])[+!+[]+[+[]]]+(!![]+[])[+!+[]]][([][[]]+[])[+!+[]]+(![]+[])[+!+[]]+((+[])[([][(![]+[])[+[]]+(![]+[])[!+[]+!+[]]+(![]+[])[+!+[]]+(!![]+[])[+[]]]+[])[!+[]+!+[]+!+[]]+(!![]+[][(![]+[])[+[]]+(![]+[])[!+[]+!+[]]+(![]+[])[+!+[]]+(!![]+[])[+[]]])[+!+[]+[+[]]]+([][[]]+[])[+!+[]]+(![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[+!+[]]+([][[]]+[])[+[]]+([][(![]+[])[+[]]+(![]+[])[!+[]+!+[]]+(![]+[])[+!+[]]+(!![]+[])[+[]]]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[][(![]+[])[+[]]+(![]+[])[!+[]+!+[]]+(![]+[])[+!+[]]+(!![]+[])[+[]]])[+!+[]+[+[]]]+(!![]+[])[+!+[]]]+[])[+!+[]+[+!+[]]]+(!![]+[])[!+[]+!+[]+!+[]]]](!+[]+!+[]+!+[]+[+!+[]])[+!+[]]+(!![]+[])[!+[]+!+[]+!+[]])()(([]+[])[([![]]+[][[]])[+!+[]+[+[]]]+(!![]+[])[+[]]+(![]+[])[+!+[]]+(![]+[])[!+[]+!+[]]+([![]]+[][[]])[+!+[]+[+[]]]+([][(![]+[])[+[]]+(![]+[])[!+[]+!+[]]+(![]+[])[+!+[]]+(!![]+[])[+[]]]+[])[!+[]+!+[]+!+[]]+(![]+[])[!+[]+!+[]+!+[]]]())[!+[]+!+[]]+(+(+!+[]+[+[]]+[+!+[]]))[(!![]+[])[+[]]+(!![]+[][(![]+[])[+[]]+(![]+[])[!+[]+!+[]]+(![]+[])[+!+[]]+(!![]+[])[+[]]])[+!+[]+[+[]]]+([]+[])[([][(![]+[])[+[]]+(![]+[])[!+[]+!+[]]+(![]+[])[+!+[]]+(!![]+[])[+[]]]+[])[!+[]+!+[]+!+[]]+(!![]+[][(![]+[])[+[]]+(![]+[])[!+[]+!+[]]+(![]+[])[+!+[]]+(!![]+[])[+[]]])[+!+[]+[+[]]]+([][[]]+[])[+!+[]]+(![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[+!+[]]+([][[]]+[])[+[]]+([][(![]+[])[+[]]+(![]+[])[!+[]+!+[]]+(![]+[])[+!+[]]+(!![]+[])[+[]]]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[][(![]+[])[+[]]+(![]+[])[!+[]+!+[]]+(![]+[])[+!+[]]+(!![]+[])[+[]]])[+!+[]+[+[]]]+(!![]+[])[+!+[]]][([][[]]+[])[+!+[]]+(![]+[])[+!+[]]+((+[])[([][(![]+[])[+[]]+(![]+[])[!+[]+!+[]]+(![]+[])[+!+[]]+(!![]+[])[+[]]]+[])[!+[]+!+[]+!+[]]+(!![]+[][(![]+[])[+[]]+(![]+[])[!+[]+!+[]]+(![]+[])[+!+[]]+(!![]+[])[+[]]])[+!+[]+[+[]]]+([][[]]+[])[+!+[]]+(![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[+!+[]]+([][[]]+[])[+[]]+([][(![]+[])[+[]]+(![]+[])[!+[]+!+[]]+(![]+[])[+!+[]]+(!![]+[])[+[]]]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[][(![]+[])[+[]]+(![]+[])[!+[]+!+[]]+(![]+[])[+!+[]]+(!![]+[])[+[]]])[+!+[]+[+[]]]+(!![]+[])[+!+[]]]+[])[+!+[]+[+!+[]]]+(!![]+[])[!+[]+!+[]+!+[]]]](!+[]+!+[]+[+!+[]])[+!+[]]+(!![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+!+[]]+(![]+[])[!+[]+!+[]+!+[]])
)
```

All this to print ``Cheers``, Daaamn!! I love this language :)


]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[Under the hood:: Array.map()]]></title>
            <link>https://kibuika.composts/array-map</link>
            <guid>array-map</guid>
            <pubDate>Sat, 16 Jul 2022 21:00:00 GMT</pubDate>
            <description><![CDATA[I have a soft spot for Array prototypes in Javascript, I use them alot, but how do they really work under the hood? Lets explore the Array.map().]]></description>
            <content:encoded><![CDATA[
As a dev, it is normal to get lost in abstractions. The moment something works, we just say a silent "Amen" then rush to twitter. We all do this, right? :)

But behind all this abstractions, something else is happening, and someone wrote it, it is not magic, it is also just Javascript. So I am starting a sequel ``Under the hood::`` that is my attempt at uncovering the inner abstracted workings of some of my favourite and common Javascript techniques.

### Array.prototype.map()

The ``.map()`` method creates a new array populated with the results of calling a provided function on every every element in the calling array ([MDN](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/map)).
Basically, given an array and an action, the ``.map()`` will perform the provided action on every item on the array and then return a new array.

Example

```js
const arr = [1, 2, 3, 4, 5]

const newArr = arr.map(i => i * 3) 
console.log(newArray) // [3, 6, 9, 12, 15]
```
Notice the resultant array ``newArr`` is the result of multiplying each of the items in ``arr`` by 3, this is defined by the function ``i => i*3``, which is just an arrow callback function (it could have been a traditional function btw  ``const newArr = arr.map(function(i){ return i * 3 })``).


From this example, we can see the parameters that the ``.map()`` method takes:
 - array (``arr``) - This is the array that ``map`` is called on

 - callback function (``i => i * 3``) - This is the function that is called on every item in the array. After completion, it returns the new item that is stored in the new array.

 - element (``i``) - This is the current element being processed.

These are just the ones we can see from our example, however, there are others like
 - index - The index of the current element

 - ``thisArg`` - The value to use as ``this`` when executing the callback function

And that's pretty much it, but we are not done yet, we have to go under the hood. 

### Under the hood

As you can imagine, we need to create a function called map, for a start

```js
let arr = [1, 2, 3, 4, 5, 6]

const map = () => {
    // our code here
}
```

We have declared a variable that has our original array and we have also declared a function called map and that is what we'll be building. Back to our code, the idea is that our function will take 2 parameters, an array and a function and then loop through every single item of the array while executing the function on it.

```js
let array = [1, 2, 3, 4, 5, 6]

const map = (arr, fn) => {
    let newArr = []; // the new array that we will return
    // loop through the array 
    for(let n of arr) {
        // run the passed function and get the result
        let res = fn(n) 
        // push the response in the array
        newArr.push(res)
    }

    return newArr
}
```

And that's pretty much it, yes, imagine, that is it. Lets throw this in the console and test

<img src="https://github.com/kibuikaCodes/kibuika.com/blob/main/content/assets/array.png?raw=true" alt="title text">

It works!! ***silent amen***, time for twitter now. :)

But really, this is just the simplest way to implement this, we have not considered alot of the parameters for the ``.map()``, but anyway, you get the gist.

So that was **map()** and how cool it is, so when should we not use it??

 - When you do not need the array being returned. - ``map()`` returns a new array and if you do not need to use this new array being returned, using the ``map()`` is considered an anti-pattern. For this, use ``forEach`` or ``for...of``

 - When you are not returning a value from the callback


 And yea, this is really actually it. I am done! ``Array.prototype`` are one of the best methods collections in Javascript and I intend to explore most of them under the hood. This was ``map()`` and I hope it makes sense for you now.

 Cheers :)











]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[Closures...I am not done yet]]></title>
            <link>https://kibuika.composts/Closures-again</link>
            <guid>Closures-again</guid>
            <pubDate>Mon, 11 Jul 2022 21:00:00 GMT</pubDate>
            <description><![CDATA[My quest for closures keeps intensifying. Maybe it has nothing to do with Javascript closures but some other kind of closure.]]></description>
            <content:encoded><![CDATA[
In my previous Closures post, I initially added ``Array prototypes`` as an example of closures and to support that, I used the example of ``Array.filter()`` that uses a filter condition declared in the global scope in order to filter. Look and feels right, but boy ooh boy, or girl ooh girl or non-binary ooh non-binary was I wrong-``ish``.

Technically, it is not the Array prototypes that are closures, it is the arrow functions that they take as arguments that are closures. Okay, look at this.

Let's create a baby that cries, smiles while eating and says its name everytime

```js
class Baby{
    constructor(name){
        this.name = name
    }

    cry(){
        console.log(`Ing'aaaaaa, I am ${this.name}`)
    }

    smileAndEat(){
        setTimeout(function(){console.log(`I love food, my name is ${this.name}`)}, 1000)
    }
}

let emma = new Baby("Emma")

emma.cry()   // Ing'aaaaaa, I am Emma
emma.smileAndEat()  // I love food, my name is
```
<img src="https://github.com/kibuikaCodes/kibuika.com/blob/main/content/assets/emma.png?raw=true" alt="title text">

Notice when we call ``emma.cry()``, the value of ``this.name`` is ``Emma`` but when we call ``emma.smileAndEat()``, the value of ``this.name`` is ``undefined``. This is because the ``setTimeout()`` function creates its own scope that does not have the value of name.

How can this be resolved?? - By binding the ``setTimeout()`` function to ``this``

```js
    .
    .
    .
    smileAndEat(){
        setTimeout(function(){console.log(`I love food, my name is ${this.name}`)}.bind(this), 1000)
    }
    .
    .
    .

```

When we rewrite our ``Baby`` class with the ``smileAndEat()`` method looking like this, as in boud by with ``this``, it works!

The rhyming is unintentional btw :)
It works because once the ``setTimeout()`` creates its own scope and tries to access the value of ``this.name``, it will not find a value but it will have a scope to fall back to (the class scope) where it will find the value of name.

<img src="https://github.com/kibuikaCodes/kibuika.com/blob/main/content/assets/kyle.png?raw=true" alt="title text">

We'll see this in the console


But is this the best way to do this? We are talking about Javascript here, not Java, of course there is a better way

#### Arrow Functions
These introduced a new way to write functions in ES6.

```js
// non-arrow functions
function sunset(){
    console.log("Sunsets are cute")
}

// arrow functions
const sunset = () => console.log("Sunsets are cute")
```

These functions are a compact alternative to traditional functional expressions, but they are limited and can't be used everywhere.
One of their differences from traditional ones is that they do not have their own bindings to ``this``, ``arguments`` or ``super``

So when we rewrite our ``smileAndEat()`` method like this:

```js
    .
    .
    .
    smileAndEat(){
        setTimeout(() => {console.log(`I love food, my name is ${this.name}`)}, 1000)
    }
    .
    .
    .
```

<img src="https://github.com/kibuikaCodes/kibuika.com/blob/main/content/assets/ken.png?raw=true" alt="title text">



It works!! 

Essentially, we have rewritten the function argument for ``setTimeout()`` as an arrow function. This is because the arrow function does not have its own ``this`` defined and unlike the traditional function expression, it falls back to the enclosing scope (class scope) where it finds the value of ``this.name``. And all this works without binding, this is the magic of Closures. Our arrow function is bound with it's lexical environment so it is able to fall back to the previous scope.


I think I have closure now, because I really need to move on and so should you.

Cheers :)






]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[Closures]]></title>
            <link>https://kibuika.composts/Closures</link>
            <guid>Closures</guid>
            <pubDate>Wed, 06 Jul 2022 21:00:00 GMT</pubDate>
            <description><![CDATA[If our function was tea and the surrounding environment was a cup - then the entire "cup of tea" is a Closure. The difference is that Closures are not every developer's "cup of tea".]]></description>
            <content:encoded><![CDATA[
I was once asked to explain closures at an interview, I froze and I still have PTSD from that experience. So I vowed to never let it happen again.

According to [MDN](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Closures), a closure is the combination of a function bundled together (enclosed) with references to its surrounding state (the lexical environment). They allow us to access an outer function's scope from within an inner function.

To understand closures, you also need to understand [scope](https://developer.mozilla.org/en-US/docs/Glossary/Scope), which is the current execution context. This is really a spiral of concepts, because now you need to have an idea of what is an execution context, but think of it as just the environment in which our Javascript is executed. There's more to it but let us just leave it at that for now, back to closures.

Given MDN's definition of a closure, we can clearly see that a closure is a function that has its own execution context(function execution context) and the execution context of the surrounding environment. So if the surrounding environment is another function execution context, it has that and if the surrounding environment is the global execution context, it has that too.

enough talk, let's code...

```js
function makeAdder(x) {
  return function (y) {
    return x + y;
  };
}

const add5 = makeAdder(5);
const add10 = makeAdder(10);

console.log(add5(2)); // 7
console.log(add10(2)); // 12

```

Here, we have a factory function (a function that creates another function), ``makeAdder(x)``, which takes in an argument ``x`` and returns an anonymous function that takes ``y`` as an argument and returns the sum of x and y.

The function factory creates two new functions ``add(5)`` and ``add(10)`` which are both closures. The magic here is that both of these functions use the same function body definition but store different lexical environments. In ``add(5)``'s lexical environment, ``x`` is 5 and in ``add(10)``'s lexical environment, ``x`` is 10. This way the functions are referencing different environments and that is why we get different results.

Let's see another example

```js
function Baby(name){
    function isCrying(){
        console.log(`${name} is crying lustily`)
    }

    function isCute(){
        console.log(`${name} is extremely cute`)
    }

    return {
        isCrying,
        isCute
    }
}

let annette = Baby("Annette")
let joe = Baby("Joe")

console.log(joe.isCrying()) // Joe is crying lustily
console.log(annette.isCrying()) // Annette is crying lustily
```

You would think the functions ``isCrying()`` and ``isCute()`` would throw an error because we are trying to use a variable that is not in their scope, but no, these are closures so we have access to ``name`` because it exists in the environment in which the functions are invoked. Simply, ``isCrying()`` and ``isCute()`` maintain a reference to their lexical environment in which an instance of ``name`` exists.

#### Some practical applications

1. React's useState Hook

    Yes, React's [useState](https://reactjs.org/docs/hooks-state.html) makes use of closures in order to keep track of references to the previous state. This way it is able to compare the new value and the previous value and decides whether to update the value in state. I will talk more about this in a later post.

2. Arrow Functions
    Imagine you are trying to filter an array given a condition.
    ```js
    const studentName = "Steve"

    const students = [{name: 'John', grade: 'A'}, {name: 'Steve', grade: 'B'},
     {name: 'Mary', grade: 'C'}, {name: 'Bob', grade: 'D'}, {name: 'Steve', grade: 'F'},
      {name: 'Jane', grade: 'F'}];
    // in this case, we want to get only details for students whose name is "Steve"

    const studentsNamedSteve = students.filter((student) => student.name === studentName); 
    // [{name: 'Steve', grade: 'B'}, {name: 'Steve', grade: 'F'}]

    ```

    From this example, we see the arrow function in``Array.filter()`` method uses the variable ``studentName`` that is in the global scope. This makes it a closure. I will explore more of Arrow Functions at a later post and we'll see the advantages.


There is alot more to Closures than I could give in this post, but closures are really powerful and you should definitely give them a spin. Thats it for now!

Cheers :)

]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[Where are my Arrays and Strings ".at"?]]></title>
            <link>https://kibuika.composts/At-Prototype</link>
            <guid>At-Prototype</guid>
            <pubDate>Mon, 27 Jun 2022 21:00:00 GMT</pubDate>
            <description><![CDATA[The EcmaScript release on June 2022 (ES2022) introduced a new method (.at), it is okay-ish.]]></description>
            <content:encoded><![CDATA[
The new method ```.at()``` of indexable values allows us to read an element at a given index. Basically like the bracket ```[]``` operator. The pro is that it supports negative indices, which the bracket operator does not.

### Let's see

```js
// array of names
let names = ["John", "Jacob", "Jingleheimer", "Schmidt"];
console.log(names[0]) // "John"   ====>>> using the bracket operator
console.log(names.at(0)); // "John"  ====>> using the new .at() method
```

This is also the case with Strings  

```js
let person = "Steve";
console.log(person[0]) // 'S'
console.log(person.at(0)) // 'S'
```

But when it comes to using negative values, this is where ```.at()``` gets the bracket ```[]``` operator at.

```js
let person = "Steve";
console.log(person[-1]); // undefined
console.log(person.at(-1)); // 'e'
```

This is a useful feature though I have not gotten a proper use-case for it, but I am sure I will use it in the future. But besides ```.at()``` There are alot of cool features that were released with ES2022, including ```error.cause```, ```Top-level await in modules```, ```Object.hasOwn(obj, propKey)``` and others. Have a look at everything [ES2022](https://262.ecma-international.org/)

Cheers :)]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[MutationObserver saved my weekend build]]></title>
            <link>https://kibuika.composts/Mutation-Observer</link>
            <guid>Mutation-Observer</guid>
            <pubDate>Mon, 27 Jun 2022 21:00:00 GMT</pubDate>
            <description><![CDATA[What it is, how it saved me from losing my mind, why you should care.]]></description>
            <content:encoded><![CDATA[
Over the weekend, I was working on some "fun" build. One of my favourite youtube channels `The Good Company KE` where I get my music mixes, does not name their videos properly. So if I am in the mood for some good pop-mix, I have to click around and fast-forward till I get the right video. Very exhausting. So I thought I could fix this using a chrome extension.

The extension's logic (simple version)  
```open youtube``` ===> ```check if it is a Grauchi Mix``` ===> ```get my comment from the video comments``` ===> ```replace this comment with the title```

This seems pretty straight forward, right?  
So let's write some code
```js
// get the video title
let videoTitle = document.querySelector("h1.title.style-scope.ytd-video-primary-info-renderer");
// lets see the value
console.log(videoTitle);
```
Ideally, if we have the right the reference to the title element, we should get the video title, so obvious.
But then I got a ```null``` when I logged to the console.  
Lets test in the console  

<img src="https://github.com/kibuikaCodes/kibuika.com/blob/main/content/assets/qs.png?raw=true" alt="title text">

It works!!!  

So it hit me that probably my code is running too early yet the title element has not been passed to the DOM tree.  

And that is where ```MutationObserver``` came in.

A ```MutationObserver``` is an interface that enables us to watch for changes being made to the DOM tree. This means, we can listen to some mutations and then perform an action that reacts according to that mutation.

The ```MutationObserver()``` constructor creates and returns a new MutationObserver which invokes the callback function you provide when changes occur in the DOM.
```js
const observer = new MutationObserver((mutations) => {}) 
// the callback can be different depending on your requirements
```

There are 3 methods we can invoke withing the MutationObserver.

 - ```observe()```. As the name suggests, this is what we invoke in order to configure the ```MutationObserver``` to begin receiving notifications. It can watch a single node or a node and its descendants.
    ```js
    observer.observe(target, config);
    // target is the node you want to listen to
    // config are options for the obsercer, could be the attributes you want to listen to, childList or subtree
    ```

 - ```disconnect()``` This stops an instance of the ```MutationObserver``` from receiving further notifications, until ```observe()``` is called again.
    ```js
    observer.disconnect();
    ```

 - ```takeRecords()``` Removes all pending notifications from the ```MutationObserver```'s notification queue and return them in a new array.


From this, I redesigned how my extension works. So not it listens for changes to the node with the video title and then executes my script. Simply:

```js
const observer = new MutationObserver(mutations => {
    mutations.forEach(mutation => {
        if(mutation.addedNodes.length){
            if(mutation.type == "childList"){
                console.log(mutation.target.innerText)
            }
        }
    })
})

const checkTitle = () => {
    let targetNode = document.querySelector("h1.title.style-scope.ytd-video-primary-info-renderer");
    if (!targetNode) {
        window.setTimeout(checkTitle, 500); // delay the execution so all content loads.
        return;
    }
    // any other logic here
    //
    //
    console.log(targetNode.innerText); // now we get our title

    observer.observe(targetNode, {childList: true, subtree: true}); // listens to DOM changes
}

checkTitle();
```

And viola!!! Now we can get our title.

I probably haven't explained enough of ```MutationObserver```, it is definitely a topic that deserves its own article. But MDN, like with everything else, has explained it and its methods very well. Here is the article [MDN MutationObserver](https://developer.mozilla.org/en-US/docs/Web/API/MutationObserver)

Cheers :)








]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[Primitives vs Objects (Value vs Reference)]]></title>
            <link>https://kibuika.composts/Value-vs-Reference</link>
            <guid>Value-vs-Reference</guid>
            <pubDate>Sat, 25 Jun 2022 21:00:00 GMT</pubDate>
            <description><![CDATA[A light look into values and references.]]></description>
            <content:encoded><![CDATA[
I'll kick this off with some examples that will act as the base of this article.

```js
const a = 1
const b = 2

a === b // false

const c = 1
const d = 1

c === d // true

const e = [1]
const f = [1]
const g = f

e === f // false
e === [1] // false
g === f // true
```

The comparison of a and b makes sense, right? But for the comparison of e and f, e and [1], g and f, that is where things get interesting. Someone who doesn't know what is actually happening will just say Javascript is weird, but it really isn't.

Javascript provides us with two types of datatypes: Primitives and Objects. Each of this datatype is passed differently to a variable. Primitives are passed by value while Objects are passed by reference.

## Primitives
Primitives are numbers, booleans, strings, symbols and special values like undefined and null

```js
const number = 2;
const boolean = true;
const string = 'Hello World!';
const missingItem = null;
const nothing = undefined;
```

Like I said, primitive values are passed by value. This means that every time you assign a primitive value to a variable, a copy of that value is created. 

```js
let a = 10; 
let b = a;

// mutate b
b = b + 10;

console.log(b) // 20
console.log(a) // 10
```

The very first statement declares a variable ```a``` and initializes it with the number ```1```. The second statement ```let b = a```, declares another variable ```b``` and initializes it with the value of the variable ```a```. Since we are dealing with primitives here, a copy of the number ```1``` is assigned to ```b```.

When we change the the value of ```b```, ```b = b + 10```, we are basically increasing the value of ```b``` by ```10```. Notice the value of ```b``` increases to ```20``` while the value of ```a``` remains the same.

## Objects
Objects are the other category od fata types that Javascript provides us. Objects include: the plain object, arrays, functions, dates, regex, etc. Anything that is not a primitive is an object in js.

```js
const person = {
    name: "Steve"
}

const array = [2, 3, 4, 5]

const functionObj = (a1, a2) => {
    return a1 + a2;
}
```

Unlike primitive values where the value assigned to a variable is the actual copy of that value, objects are assigned by reference. This means that when you declare a variable ```person``` and assign it an object, that object is created in memory and the address of that memory location is assigned to the variable ```person```.

Let's break this down.
```js 
const person = {
    name: "Steve"
}
```
The object ```{name: "Steve"}``` is created in memory and the location of that memory is, let's say ```1234567```, this is the address that points to that location in memory. Ideally this ```address``` is what is "assigned" to the variable ```person```.
So instead of ```person``` holding an actual copy of the onject, it just points to a location in memory where the object has been created.

```person =============> 1234567```
```js
 // address 1234567
 {
    name: "Steve"
 }
 ```

 What happens when we assign a new variable the value of an existing object?

 ```js
 let person = {
    name: "Steve"
 }

 let newPerson = person;

 newPerson.age = 24;

 console.log(person) // {name: "Steve", age: 24}
 console.log(newPerson) // {name: "Steve", age: 24}

 ```

 What tha heck!!. Yes. Remember when we said that ```Objects```(the data type) points to memory locations? This is what is happening. Our object ```{name: "Steve"}``` is created in memory and its address is "assigned" to the variable person. When we declare a new variable ```newPerson``` and assign it the value of ```person```, what we are doing is assigning a reference to the memory location. Basically, both ```person``` and ```newPerson``` are pointing to the same memory location.

 ```person ============> 1234567```
 ```newPerson ===========> 1234567```

 That is why when we add a new property ```age``` with a value of ```24``` to ```newPerson```, this also applies to ```person``` because it is pointing to the same memory location.

 And this is what ```pass by reference``` is all about. We are passing references and not actual values.


 ### Highlights
 - Javascript is not weird
 - Pass by value means an actual copy of that value is assigned to the variable. This happens with ```Primitives``` data types (numbers, strings, boolean, null, undefined)
 - Pass by reference means that the value is created in memory and an address to that memory location is what the variable will "hold". This happens with ```Objects``` data types (object, array, function, date, regex)
]]></content:encoded>
        </item>
    </channel>
</rss>